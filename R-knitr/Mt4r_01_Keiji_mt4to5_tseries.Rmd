Mt4r_01_Keiji_mt4to5_tseries
==================================================================================================================================
## Motivational Buckets
### 1.1) (size: )  Keiji is the author of a script, namely "mt4to5rewrite_sample_v4_2.mq4", that converts MT4 code into MT5 code. This R Markdown file bases the main function on this script, in particular the start() function, but rather to convert MT4 to SqLite. 
### 1.2) (size: ) There are SIX (6) internal functions: (i) FuncAddTop(); (ii) FuncAddInInit(); (iii) FuncAddInStart(); (iv) FuncAddInDeinit(); (v) FuncFind(); (vi) FuncRewrite().
### 1.3) (size: ) There are FIVE (5) include files: (i) "mt4accountinfo.mqh"; (ii) "mt4string.mqh"; (iii) "mt4datetime.mqh"; (iv) "mt4objects_1.mqh"; and (v) "mt4timeseries_2.mqh".

```{r}
if( Sys.info()["sysname"] == "Linux" )
{
  suppressPackageStartupMessages(source("~/100 FxOption/103 FxOptionVerBack/080 Fx Git/R-source/PlusReg.R", echo=FALSE))
}
if( Sys.info()["sysname"] == "Windows" )
{
  suppressPackageStartupMessages(source("C:/Users/denbrige/100 FxOption/103 FxOptionVerBack/080 Fx Git/R-source/PlusReg.R", echo=FALSE))
}
suppressPackageStartupMessages(source(paste0(RegRSourceDir(),"PlusFile.R"), echo=FALSE))
suppressPackageStartupMessages(library(R.utils))
suppressPackageStartupMessages(library(tseries))
MtrConvertStr <- function(name.str, exe.dir=paste0(RegProgramDir(),"mq4_converter/"),
                       ea.dir=RegEaDir(), java.dir=RegJavaDir())
{
  ea.str    <- paste0(name.str, ".mq4")
  java.str  <- paste0(name.str, ".java")
  exe.str   <- "mq4_writer.exe"
  cmd.str   <- paste0('"', exe.dir, exe.str, '" "', ea.dir, ea.str, 
                    '" java "', java.dir, java.str, '"')
  if( !file.exists(paste0(exe.dir, exe.str)) )
    stop(paste0(exe.str, ' MUST be installed first'))
  if( !file.exists(paste0(ea.dir, ea.str)) )
    stop(paste0(ea.str, ' file MUST exists'))
  errNum <- RegSystemNum(cmd.str)
  if( errNum!=0 | !file.exists(paste0(java.dir, java.str)) )
    return( paste0(errNum, ': ', java.str, ' is missing (OR NOT converted correctly)') )
  else
    return( paste0(java.dir, java.str) )
}
name.str  <- "Pro_Bot_EURUSD_m15_Risk"
#name.str  <- "Gday mark 2"
java.str  <- MtrConvertStr(name.str)
if( file.exists(java.str) )
  mt.list <- lapply(readLines(paste0(java.str)), function(x) scan(text=x, sep=" ", 
                                                 what=c("char"), strip.white=c(FALSE)))
```
### 1.1.1) (size: ) In this instance, we "normalize" the Expert Advisor (EA) named "Pro_Bot_EURUSD_m15_Risk.mq4" into a java file "Pro_Bot_EURUSD_m15_Risk.java" by using the executable file "mq4_writer.exe". "Normalize" means to clean up and standardize the format of the code without changing its implementation. Ideally, we would have preferred to "normalize" the EA into a MQ4 file but there is no utility to perform this.
### 1.1.2) After the normalization process, we then read the java file into a list, where an element of the list corresponds to a line in the text file, and EACH element contains a vector of characters (including indentation).

```{r}
head(mt.list)
MtrFindCmtDfr <- function(mt.list)
{
  endNum <- length(mt.list)
  retDfr <- dataFrame( colClasses=c(Token="character", Open="numeric", Close="numeric",
                                    First="numeric"), nrow=0 )
  rowNum <- which(lapply(mt.list, function(x) { sum(grep("//", x)) })>0)
  for( n in seq_along(rowNum) )
  {
    openNum     <- rowNum[n]
    indentNum   <- which(nchar(mt.list[[openNum]])>0)
    rDfr        <- data.frame("cmt", openNum, openNum, indentNum[1] )
    names(rDfr) <- names(retDfr)
    retDfr      <- rbind(retDfr, rDfr)
  }
  rowNum    <- which(lapply(mt.list, function(x) { sum(grep("\\/\\*", x)) })>0)
  rowcNum   <- which(lapply(mt.list, function(x) { sum(grep("\\*\\/", x)) })>0)
  for( n in seq_along(rowNum) )
  {
    openNum     <- rowNum[n]
    indentNum   <- which(nchar(mt.list[[openNum]])>0)
    closeNum    <- rowcNum[n]
    rDfr        <- data.frame("cmt", openNum, closeNum, indentNum[1] )
    names(rDfr) <- names(retDfr)
    retDfr      <- rbind(retDfr, rDfr)
  }
  retDfr
}
MtrFindLoopDfr <- function(mt.list, cmtDfr)
{
  endNum <- length(mt.list)
  retDfr <- dataFrame( colClasses=c(Token="character", Open="numeric", 
                                    Close="numeric", First="numeric"), nrow=0 )
  rowNum <- which(lapply(mt.list, function(x) { sum(grep("for", x)) })>0)
  for( n in seq_along(rowNum) )
  {
    openNum     <- rowNum[n]
    indentNum   <- which(nchar(mt.list[[openNum]])>0)
    #---  Identify non-valid tokens
    #     (1) tokens may be within a comment: (a) // for; (b) /* for */
    #     (2) tokens may be within a string, i.e. " this is for "
    isOpenCmt   <- nrow(cmtDfr[cmtDfr$Open<=openNum & openNum<=cmtDfr$Close,])>0
    if( length(indentNum)>1 )
      isOpenStr   <- substr(mt.list[[openNum]][indentNum[2]],1,1)!="("
    else
      isOpenStr   <- TRUE
    if( !isOpenCmt &  !isOpenStr )
    {
      #---  Knowledge when "for" has braces OR NOT
      #     (1) check if next token is "{"
      nextNum     <- openNum+1
      indnxtNum   <- which(nchar(mt.list[[nextNum]])>0)
      if( indentNum[1]==indnxtNum[1] )
        isOpenBrs   <- substr(mt.list[[nextNum]][indnxtNum[1]],1,1)=="{"
      else
        isOpenBrs   <- FALSE
      if( !isOpenBrs )
        startNum <- openNum + 1
      else
        startNum <- openNum + 2
      for( mRow in startNum:endNum )
      {
        iNum <- which(nchar(mt.list[[mRow]])>0)
        if( length(iNum)>0 )
          if( iNum[1]==indentNum[1] )
          {
            isCloseCmt  <- nrow(cmtDfr[cmtDfr$Open==mRow,])>0
            if( !isCloseCmt ) break
          }
      }
      if( !isOpenBrs ) 
        closeNum  <- mRow - 1
      else
        closeNum  <- mRow
      rDfr        <- data.frame("for", openNum, closeNum, indentNum[1] )
      names(rDfr) <- names(retDfr)
      retDfr      <- rbind(retDfr, rDfr)
    }
  }
  retDfr
}
cmtDfr <- MtrFindCmtDfr(mt.list)
cmtDfr
forDfr <- MtrFindLoopDfr(mt.list, cmtDfr)
forDfr
sql.list <- list()
j <- 1
for( i in seq_along(mt.list) )
{
  #--- Read Line
  lineChr <- mt.list[[i]]
  
  #--- Account Query
  lineChr <- gsub("AccountFreeMargin", "GhostAccountFreeMargin", lineChr)
  
  #--- Sql Query  
  lineChr <- gsub("OrderTicket",      "GhostOrderTicket", lineChr)
  lineChr <- gsub("OrderSymbol",      "GhostOrderSymbol", lineChr)
  lineChr <- gsub("OrderOpenPrice",   "GhostOrderOpenPrice", lineChr)
  lineChr <- gsub("OrderMagicNumber", "GhostOrderMagicNumber", lineChr)
  lineChr <- gsub("OrderType",        "GhostOrderType", lineChr)
  lineChr <- gsub("OrderStopLoss",    "GhostOrderStopLoss", lineChr)
  lineChr <- gsub("OrderTakeProfit",  "GhostOrderTakeProfit", lineChr)
  
  #--- Sql Query with special cases
  lineChr <- gsub("OrderSelect", "GhostOrderSelect", lineChr)
  subBln  <- length(grep("GhostOrdersSelect", lineChr)) > 0
  posBln  <- length(grep("SELECT_BY_POS", lineChr)) > 0
  tktBln  <- length(grep("SELECT_BY_TICKET", lineChr)) > 0
  trdBln  <- length(grep("MODE_TRADES", lineChr)) > 0
  hsyBln  <- length(grep("MODE_HISTORY", lineChr)) > 0
  if( posBln & subBln )
  {
    
  }
  if( tktBln & subBln )
  {
    
  }  
  
  lineChr <- gsub("OrdersTotal", "GhostOrdersTotal", lineChr)
  subBln  <- length(grep("GhostOrdersTotal", lineChr)) > 0
  forBln  <- length(grep("for", lineChr)) > 0
  if( forBln & subBln )
  {
    #--- Prepend a line
    sql.list[[j]] <- c("int", "total", "=", "GhostOrdersTotal();")
    j <- j + 1
    lineChr <- gsub("GhostOrdersTotal\\(\\)", "total", lineChr)
  }
  
  #--- Sql Command
  lineChr <- gsub("OrderSend",   "GhostOrderSend", lineChr)
  lineChr <- gsub("OrderModify", "GhostOrderModify", lineChr)
  
  #--- Write Line
  sql.list[[j]] <- lineChr
  j <- j + 1
}
sql.list
```
### 1.2.1) (size: ) The internal function FuncRewrite() has an equivalent function gsub() in R. 

