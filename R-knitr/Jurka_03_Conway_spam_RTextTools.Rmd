Jurka_03_Conway_spam_RTextTools
==================================================================================================================================
## Motivational Buckets
### 1) (size: >>20) RTextTools has been used by Jurka to identify a breast cancer as benign or malignant. However, the predictors are discrete numbers that are pre-processed into text. Ultimately, we would like to use RTextTools to predict whether an advertisement is ham (relevant) OR spam (irrelevant). However, as this is largely an unexplored area, which may result in low accuracy in prediction, I decided to explore the feasibility of building a model used to classify large text, i.e. raw text without ANY features.
### 1.1) In the book "Machine Learning for Hackers" by Conway (2012), there is a chapter devoted to bayesian spam classifier used for email. However, our interest lies NOT in the bayesian algorithm, but the public database and the R functions to load the database. Once we have the data loaded, we can build a prediction model using the RTextTools package.

```{r}
suppressPackageStartupMessages(require(RTextTools))
suppressPackageStartupMessages(require(tm))
source("C:/Users/denbrige/100 FxOption/103 FxOptionVerBack/080 Fx Git/R-source/PlusReg.R", echo=FALSE)
spam.dir <- paste0(RegGetRNonSourceDir(), "spamassassin/")
get.msg <- function(path.dir)
{
  con <- file(path.dir, open="rt", encoding="latin1")
  text <- readLines(con)
  msg <- text[seq(which(text=="")[1]+1,length(text),1)]
  close(con)
  return(paste(msg, collapse="\n"))
}
get.all <- function(path.dir)
{
  all.file <- dir(path.dir)
  all.file <- all.file[which(all.file!="cmds")]
  msg.all <- sapply(all.file, function(p) get.msg(paste0(path.dir,p)))
}
easy_ham.all    <- get.all(paste0(spam.dir, "easy_ham/"))
easy_ham_2.all  <- get.all(paste0(spam.dir, "easy_ham_2/"))
hard_ham.all    <- get.all(paste0(spam.dir, "hard_ham/"))
hard_ham_2.all  <- get.all(paste0(spam.dir, "hard_ham_2/"))
spam.all        <- get.all(paste0(spam.dir, "spam/"))
spam_2.all      <- get.all(paste0(spam.dir, "spam_2/"))
```
### 1.1.1) (size: 20) We explore the raw data, which is the SpamAssassin public corpus, available for FREE download at http://spamassassin.apache.org/publiccorpus/. The files are separated into easy_ham, hard_ham and spam. Of which, there are TWO (2) sets of files EACH, e.g. easy_ham and easy_ham_2. We will use the FIRST set for training data, and the SECOND set for testing data.
### 1.1.2) EACH set resides in its own subfolder within the spamassassin folder, which is in R-nonsource. For example, the first and second sets for easy_ham resides in R-nonsource/spamassassin/easy_ham, and R-nonsource/spamassassin/easy_ham_2, respectively.
### 1.1.3) The raw data include the headers and the message text. Because we are focusing on ONLY the email message body, we need to extract this text from the message files. The "null line" separating the header from the body of an email is part of the protocol definition.
### 1.1.4) We create text corpuses from EACH set of files by creating a function get.msg() that opens EACH file, finds the FIRST line break, and returns the text below that break as a character vector with a SINGLE text element.
### 1.1.5) To create our vector of messages, we use the get.all() function, which will apply get.msg() function to ALL of the filenames within a set (specified by a folder) and construct a vector of messages from the returned text.
### 1.1.6) However, we may increase execution speed by saving the processed data later as an RDA file and to load that file instead.

```{r}
head(easy_ham.all)
```
```{r}
data <- data[-1]
thick <- as.vector(apply(as.matrix(data[1], mode="character"),1,paste,"clump",sep="",collapse=""))
size <- as.vector(apply(as.matrix(data[2], mode="character"),1,paste,"size",sep="",collapse=""))
shape <- as.vector(apply(as.matrix(data[3], mode="character"),1,paste,"shape",sep="",collapse=""))
adhesion <- as.vector(apply(as.matrix(data[4], mode="character"),1,paste,"adhesion",sep="",collapse=""))
single <- as.vector(apply(as.matrix(data[5], mode="character"),1,paste,"single",sep="",collapse=""))
nuclei <- as.vector(apply(as.matrix(data[6], mode="character"),1,paste,"nuclei",sep="",collapse=""))
chromatin <- as.vector(apply(as.matrix(data[7], mode="character"),1,paste,"chromatin",sep="",collapse=""))
nucleoli <- as.vector(apply(as.matrix(data[8], mode="character"),1,paste,"nucleoli",sep="",collapse=""))
mitoses <- as.vector(apply(as.matrix(data[9], mode="character"),1,paste,"mitoses",sep="",collapse=""))
training_data <- cbind(data[10],thick,size,shape,adhesion,single,nuclei,chromatin,nucleoli,mitoses)
```
### 1.1.3) (size: 13) The processed data can be saved as an RDA file here, after transforming the numerical columns into characters.
### 1.1.4) It is apparent that the predictors used are first converted into character by appending a text to EACH numerical value. The reason I can think of is that it is either (a) a limitation of the RTextTools package; or (b) it is more robust and efficient to do so using the package.

```{r}
source("C:/Users/denbrige/100 FxOption/103 FxOptionVerBack/080 Fx Git/R-source/PlusReg.R", echo=FALSE)
cancer.str <- paste0(RegGetRNonSourceDir(),"Jurka_02_cancer.rda")
if( !file.exists(cancer.str) )
{
  save(training_data, file=cancer.str)
}
head(training_data)
```
```{r}
training_data <- training_data[sample(1:699,size=600,replace=FALSE),]
training_codes <- training_data[1]
training_data <- training_data[-1]
```
### 1.2.1) (size: 16) First, to ensure a reproducible research, the function set.seed() should be used. However, the author does NOT use this function before sampling 600 rows from the data. An issue here is why didn't the author just use ALL 699 rows in the data? The only reason I can think of is that he is applying the bootstrapping method, however this method requires sampling WITH replacement.
### 1.2.2) The sample of 600 rows is also broken into TWO (2) data frames: (a) training_codes contains the outcome variable; and (b) training_data contains NINE (9) predictors.
### 1.2.3) The outcome values can be changed here by just modifying the values in training_codes, which is a binary outcome consisting of an integer value TWO (2) OR FOUR (4). Would the recall accuracy DECREASE if we modify the outcome values?
### 1.2.4) The predictor values can be changed here by modifying the values in training_data. We could for example, randomizing missing values (NA) and observe how the models would handle missing data? 
### 1.2.5) For a model that has a binary outcome, it is suggested that a logistic regression be applied rather than a linear regression. However, the topic of logistic regression is beyond the scope of this analysis.

```{r}
class(training_codes)
head(training_codes)
class(training_data)
head(training_data)
table(training_codes)
tMissingData <- training_data[1]
for( i in 1:10 )
{
  r <- sample(1:nrow(tMissingData), size=1, replace=FALSE)
  c <- sample(1:ncol(tMissingData), size=1, replace=FALSE)
  tMissingData[r,c] <- NA
}
```
```{r}
matrix <- create_matrix(training_data, language="english", removeNumbers=FALSE, stemWords=FALSE, removePunctuation=FALSE, weighting=weightTfIdf)
container <- create_container(matrix,t(training_codes),trainSize=1:200, testSize=201:600,virgin=FALSE)
models <- train_models(container, algorithms=c("MAXENT","SVM","GLMNET","SLDA","TREE","BAGGING","BOOSTING","RF"))
```
### 1.2.5) (size: 19) The RTextTools package [2] is a wrapper for the tm package [3]. Therefore, the steps for training a model MUST be as follows: (i) Create a document-term matrix; (ii) Create a container; (iii) Feed the container to the machine learning algorithm.
### 1.2.6) To create a matrix, you need to pass it a either a character vector, e.g. data$Text, or a data frame of columns containing predictors ONLY. There are some important parameters, such as: (i) language (default: "english"), (ii) minWordLength (default: 3) - a word should contain AT LEAST this number of letters to be included in the matrix, (iii) removeNumbers (default: FALSE) - to specify whether to remove numbers; (iv) removePunctuation (default: TRUE) - to specify whether to remove punctuations; (v) stemWords (default: FALSE) - to specify whether to remove stemwords, e.g. "ing", (vi) weighting (default: weightTf) - this parameter is from the package tm.
### 1.2.7) For example, to create a matrix using a character vector, e.g. data$Text, then you should apply the parameters: (i) language="english"; (ii) minWordLength=3; (iii) removeNumbers=TRUE; (iv) removePunctuation=TRUE; and (v) stemWords=TRUE.
### 1.2.8) As another example, should you pass it a hand-coded data frame, e.g. breast cancer, then you should apply the following parameters: (i) language="english"; (ii) minWordLength=3; (iii) removeNumbers=FALSE; (iv) removePunctuation=FALSE; and (v) stemWords=FALSE.
### 1.2.9) To create a container, you need to pass it BOTH a document-term matrix AND an outcome vector, e.g. data$Topic. The important parameters are: (i) trainSize (default: NULL) - a range specifying the row numbers in the matrix to use for training the model; (ii) testSize (default: NULL) - a range specifying the row numbers in the matrix to use for out-of-sample testing; (iii) virgin - to specify whether the testing set is unclassified data with no true value. For example, when the virgin flag is set to FALSE, indicating that all data in the training and testing sets have corresponding labels, create_analytics() will check the results of the learning algorithms against the true value to determine the accuracy of the process. However, if the virgin flag is set to TRUE, indicating that the testing set is unclassified data with NO known true value, create_analytics() will return as much information as possible WITHOUT comparing EACH predicted value to its true label.
### 1.2.10) To create a model, you need to pass it a container. The most important parameter is algorithm - a string to specify which algorithm to use. For expediency, users replicating this analysis may want to use just the three low-memory algorithms: (i) "SVM" - Support Vector Machines; (ii) "GLMNET"; and (iii) "MAXENT" - Maximum Entrophy [2]. A convenience train_models() function trains all models at once by passing in a vector of model requests, while the print_algorithms() function list ALL NINE (9) available algorithms.

```{r}
missing.dtm <- create_matrix(tMissingData, language="english", removeNumbers=FALSE, stemWords=FALSE, removePunctuation=FALSE, weighting=weightTfIdf)
missing.ctn <- create_container(missing.dtm, t(training_codes),trainSize=1:200, testSize=201:600,virgin=FALSE)
missing.models <- train_models(missing.ctn, algorithms=c("MAXENT","SVM","GLMNET","SLDA","TREE","BAGGING","BOOSTING","RF"))
```
```{r}
results <- classify_models(container, models)
analytics <- create_analytics(container, results)
analytics@ensemble_summary
```
### 1.2.11) (size: 22) The functions classify_model() and classify_models() use the same syntax as train_model(). Each model created in the previous step is passed on to classify_model(), which then returns the classified data.
### 1.2.12) The function create_analytics() returns a container with FOUR (4) different summaries: (i) ensemble (consensus) - refers to whether multiple algorithms make the same prediction concerning the classification; (ii) algorithm - provides a breakdown of EACH algorithm's performance for each unique label in the classified data, e.g. EACH topic category (outcome); (iii) label - provides statistics for EACH unique label in the classified data; and (iv) document - provides ALL the raw data available for each document, including EACH algorithm's prediction.
### 1.2.13) Precision refers to how often a case the algorithm predicts as belonging to a class actually belongs to that class. For example, in the context of the USCongress data, precision tells us what proportion of bills an algorithm deems to be about defense are actually about defense(based on the human-assigned labels).
### 1.2.14) In contrast, recall refers to the proportion of bills in a class the algorithm correctly assigns to that class. For example, what percentage of actual defense bills did the algorithm correctly classify?
### 1.2.15) F-scores produce a weighted average of both precision and recall, where the highest level of performance is equal to ONE (1) and the lowest ZERO (0).
### 1.2.16) Coverage simply refers to the percentage of documents that meet the recall accuracy threshold. For instance, say we find that when seven algorithms agree on the label of a bill, our overall accuracy is 90% (when checked against our true values). Then, let's say, we find that only 20% of our bills meet that criterion. If we have 10 bills and only two bills meet the seven ensemble agreement threshold, then our coverage is 20%. Mathematically, if k represents the percent of cases that meet the ensemble threshold, and n represents total cases, coverage is calculated as k/n. The general trend is for coverage to decrease while recall increases. For example, just 11% of the congressional bills in our data have nine algorithms that agree. However, recall accuracy is 100% for those bills when the 9 algorithms do agree. Considering that 90% is often social scientists' inter-coder reliability standard, one may be comfortable using a 6 ensemble agreement with these data because we label 66% of the data with accuracy at 90%.
### 1.2.17) By randomizing TEN (1) missing values (NA) into the predictors, we note that coverage has increased but recall has decreased significantly.

```{r}
doc <- analytics@document_summary
doc[doc$MANUAL_CODE != doc$CONSENSUS_CODE, 17:18]
missing.results <- classify_models(missing.ctn, missing.models)
missing.analytics <- create_analytics(missing.ctn, missing.results)
missing.analytics@ensemble_summary
```

## References
### Jurka, RTextTools: a machine learning library for text classification. URL: http://www.rtexttools.com/. Accessed on 18-Feb-2013
### Jurka et al (2012), RTextTools: A Supervised Learning Package for Text Classification.
### Feinerer, K. Hornik and D. Meyer. Text Mining Infrastructure in R. Journal of Statistical Software, 25
(5). 2008. URL http://www.jstatsoft.org/v25/i05/.